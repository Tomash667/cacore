//-----------------------------------------------------------------------------
// dodatkowe funkcje matematyczne directx
// można zrobić to używając innych ale tak jest krócej
//-----------------------------------------------------------------------------
inline MATRIX* D3DXMatrixTranslation(MATRIX* mat, const VEC3& pos)
{
	return D3DXMatrixTranslation(mat, pos.x, pos.y, pos.z);
}

inline MATRIX* D3DXMatrixScaling(MATRIX* mat, const VEC3& scale)
{
	return D3DXMatrixScaling(mat, scale.x, scale.y, scale.z);
}

inline MATRIX* D3DXMatrixScaling(MATRIX* mat, float scale)
{
	return D3DXMatrixScaling(mat, scale, scale, scale);
}

inline MATRIX* D3DXMatrixRotation(MATRIX* mat, const VEC3& rot)
{
	return D3DXMatrixRotationYawPitchRoll(mat, rot.y, rot.x, rot.z);
}

inline void D3DXVec2Normalize(VEC2& v)
{
	D3DXVec2Normalize(&v, &v);
}

inline void D3DXVec3Normalize(VEC3* v)
{
	D3DXVec3Normalize(v, v);
}

inline VEC3* D3DXVec3Transform(VEC3* out, const VEC3* in, const MATRIX* mat)
{
	D3DXVECTOR4 v;
	D3DXVec3Transform(&v, in, mat);
	out->x = v.x;
	out->y = v.y;
	out->z = v.z;
	return out;
}

inline void VEC3Multiply(VEC3& out, const VEC3& v1, const VEC3& v2)
{
	out.x = v1.x * v2.x;
	out.y = v1.y * v2.y;
	out.z = v1.z * v2.z;
}

inline void D3DXQuaternionRotation(QUAT& q, const VEC3& rot)
{
	D3DXQuaternionRotationYawPitchRoll(&q, rot.y, rot.x, rot.z);
}


//-----------------------------------------------------------------------------
// BitStream source
class BitStreamSource : public StreamSource
{
public:
	BitStreamSource(BitStream* bitstream, bool write);

	inline bool IsFile() const { return false; }
	bool Read(void* ptr, uint data_size);
	bool Skip(uint data_size);
	void Write(const void* ptr, uint data_size);

private:
	BitStream* bitstream;
	bool write;
};

//=================================================================================================
BitStreamSource::BitStreamSource(BitStream* bitstream, bool write) : bitstream(bitstream), write(write)
{
	assert(bitstream);
	size = bitstream->GetNumberOfBytesUsed();
	offset = (write ? bitstream->GetWriteOffset() : bitstream->GetReadOffset()) / 8;
	valid = true;
}


//=================================================================================================
bool BitStreamSource::Read(void* ptr, uint data_size)
{
	assert(ptr && !write);
	if(!Ensure(data_size))
		return false;
	bitstream->Read((char*)ptr, data_size);
	offset += data_size;
	return true;
}

//=================================================================================================
bool BitStreamSource::Skip(uint data_size)
{
	assert(!write);
	if(!Ensure(data_size))
		return false;
	offset += data_size;
	uint pos = offset * 8;
	if(write)
		bitstream->SetWriteOffset(pos);
	else
		bitstream->SetReadOffset(pos);
	return true;
}

//=================================================================================================
void BitStreamSource::Write(const void* ptr, uint data_size)
{
	assert(ptr && write);
	bitstream->Write((const char*)ptr, data_size);
	size += data_size;
	offset += data_size;
}

//=================================================================================================
StreamReader::StreamReader(BitStream& bitstream)
{
	source = StreamSourcePool::Get<BitStreamSource>(&bitstream, false);
	ok = source->IsValid();
}

//=================================================================================================
StreamWriter::StreamWriter(BitStream& bitstream)
{
	source = StreamSourcePool::Get<BitStreamSource>(&bitstream, true);
}

//template<typename T, typename T2>
	//inline INT2(T _x, T2 _y) : x(int(_x)), y(int(_y)) {}
	
	
	
	
/*inline VEC2 lerp(const VEC2& v1, const VEC2& v2, float t)
{
	VEC2 out;
	D3DXVec2Lerp(&out, &v1, &v2, t);
	return out;
}*/

/*inline VEC3 lerp(const VEC3& v1, const VEC3& v2, float t)
{
	VEC3 out;
	D3DXVec3Lerp(&out, &v1, &v2, t);
	return out;
}*/
